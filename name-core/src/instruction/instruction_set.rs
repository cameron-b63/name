use crate::{
    elf_def::RelocationEntryType,
    instruction::{
        implementation,
        information::{wrap_imp, ArgumentType, InstructionInformation, InstructionType},
    },
};

use std::sync::LazyLock;

/// This is the entire implemented instruction set (regular CPU instructions) for NAME.
/// The assembler searches through this table using the mnemonic field.
/// The emulator performs a lookup based on op_code and funct_code, and then uses the associated implementation.
/// The implementation below is based on the following [specification](https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf).

// The definition for this struct is very descriptive - I encourage you to go read it.
pub static INSTRUCTION_SET: LazyLock<Vec<InstructionInformation>> = LazyLock::new(|| {
    vec![
        InstructionInformation {
            mnemonic: "add",
            op_code: 0x00,
            funct_code: Some(0x20),
            implementation: wrap_imp(implementation::add),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "addi",
            op_code: 0x08,
            funct_code: None,
            implementation: wrap_imp(implementation::addi),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "addiu",
            op_code: 0x09,
            funct_code: None,
            implementation: wrap_imp(implementation::addiu),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "addu",
            op_code: 0x00,
            funct_code: Some(0x21),
            implementation: wrap_imp(implementation::addu),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "and",
            op_code: 0x00,
            funct_code: Some(0x24),
            implementation: wrap_imp(implementation::and),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "andi",
            op_code: 0x0c,
            funct_code: None,
            implementation: wrap_imp(implementation::andi),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "beq",
            op_code: 0x04,
            funct_code: None,
            implementation: wrap_imp(implementation::beq),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "beql",
            op_code: 0x14,
            funct_code: None,
            implementation: wrap_imp(implementation::beql),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgez",
            op_code: 0x01,
            funct_code: Some(0x01),
            implementation: wrap_imp(implementation::bgez),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgezal",
            op_code: 0x01,
            funct_code: Some(0x11),
            implementation: wrap_imp(implementation::bgezal),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgezall",
            op_code: 0x01,
            funct_code: Some(0x13),
            implementation: wrap_imp(implementation::bgezall),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgezl",
            op_code: 0x01,
            funct_code: Some(0x03),
            implementation: wrap_imp(implementation::bgezl),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgtz",
            op_code: 0x07,
            funct_code: None,
            implementation: wrap_imp(implementation::bgtz),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgtzl",
            op_code: 0x17,
            funct_code: None,
            implementation: wrap_imp(implementation::bgtzl),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "blez",
            op_code: 0x06,
            funct_code: None,
            implementation: wrap_imp(implementation::blez),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "blezl",
            op_code: 0x16,
            funct_code: None,
            implementation: wrap_imp(implementation::blezl),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltz",
            op_code: 0x01,
            funct_code: Some(0x00),
            implementation: wrap_imp(implementation::bltz),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltzal",
            op_code: 0x01,
            funct_code: Some(0x10),
            implementation: wrap_imp(implementation::bltzal),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltzall",
            op_code: 0x01,
            funct_code: Some(0x12),
            implementation: wrap_imp(implementation::bltzall),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltzl",
            op_code: 0x01,
            funct_code: Some(0x02),
            implementation: wrap_imp(implementation::bltzl),
            instruction_type: InstructionType::RegImmIType,
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bne",
            op_code: 0x05,
            funct_code: None,
            implementation: wrap_imp(implementation::bne),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bnel",
            op_code: 0x15,
            funct_code: None,
            implementation: wrap_imp(implementation::bnel),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "break",
            op_code: 0x00,
            funct_code: Some(0x0D),
            implementation: wrap_imp(implementation::break_instr),
            instruction_type: InstructionType::RType,
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "cache",
            op_code: 0x2f,
            funct_code: None,
            implementation: wrap_imp(implementation::cache),
            instruction_type: InstructionType::IType,
            args: &[
                ArgumentType::Immediate,
                ArgumentType::Immediate,
                ArgumentType::Rs,
            ],
            alt_args: None,
            relocation_type: None,
        },
        // I'm going to purposefully ignore CACHEE since we don't have an acutal priviliged resource setup.
        InstructionInformation {
            mnemonic: "clo",
            op_code: 0x1c,
            funct_code: Some(0x21),
            implementation: wrap_imp(implementation::clo),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "clz",
            op_code: 0x1c,
            funct_code: Some(0x20),
            implementation: wrap_imp(implementation::clz),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        // This is a special case. Documentation dictates some CO field?
        InstructionInformation {
            mnemonic: "deret",
            op_code: 0x10,
            funct_code: Some(0x1f),
            implementation: wrap_imp(implementation::deret),
            instruction_type: InstructionType::RType,
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        // I'm ignoring the DI (disable interrupts) instruction
        // since I don't even know where to really start.
        // I know for sure that it doesn't really apply to us.
        InstructionInformation {
            mnemonic: "div",
            op_code: 0x00,
            funct_code: Some(0x1a),
            implementation: wrap_imp(implementation::div),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "divu",
            op_code: 0x00,
            funct_code: Some(0x1b),
            implementation: wrap_imp(implementation::divu),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        // Similarly ignoring EI (enable interrupts).
        // See DI.
        InstructionInformation {
            mnemonic: "eret",
            op_code: 0x10,
            funct_code: Some(0x18),
            implementation: wrap_imp(implementation::eret),
            instruction_type: InstructionType::RType,
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        // Special case. Could probably be excluded. See bit 6.
        InstructionInformation {
            mnemonic: "eretnc",
            op_code: 0x10,
            funct_code: Some(0x18),
            implementation: wrap_imp(implementation::eret),
            instruction_type: InstructionType::RType,
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ext",
            op_code: 0x1f,
            funct_code: Some(0x00),
            implementation: wrap_imp(implementation::ext),
            instruction_type: InstructionType::RType,
            args: &[
                ArgumentType::Rt,
                ArgumentType::Rs,
                ArgumentType::Immediate,
                ArgumentType::Immediate,
            ],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ins",
            op_code: 0x1f,
            funct_code: Some(0x04),
            implementation: wrap_imp(implementation::ins),
            instruction_type: InstructionType::RType,
            args: &[
                ArgumentType::Rt,
                ArgumentType::Rs,
                ArgumentType::Immediate,
                ArgumentType::Immediate,
            ],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "j",
            op_code: 0x02,
            funct_code: None,
            implementation: wrap_imp(implementation::j),
            instruction_type: InstructionType::JType,
            args: &[ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::R26),
        },
        InstructionInformation {
            mnemonic: "jal",
            op_code: 0x03,
            funct_code: None,
            implementation: wrap_imp(implementation::jal),
            instruction_type: InstructionType::JType,
            args: &[ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::R26),
        },
        InstructionInformation {
            mnemonic: "jalr",
            op_code: 0x00,
            funct_code: Some(0x09),
            implementation: wrap_imp(implementation::jalr),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs],
            alt_args: Some(&[&[ArgumentType::Rs]]),
            relocation_type: None,
        },
        // I'm going to purposefully ignore *.HB because
        // that's some hardware business I won't get to for a long time.
        // JALX also doesn't apply since we're not including micro MIPS.
        InstructionInformation {
            mnemonic: "jr",
            op_code: 0x00,
            funct_code: Some(0x08),
            implementation: wrap_imp(implementation::jr),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        // JR.HB is ignored, as stated above.
        InstructionInformation {
            mnemonic: "lb",
            op_code: 0x20,
            funct_code: None,
            implementation: wrap_imp(implementation::lb),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // LBE (load byte EVA) doesn't apply to us since we don't have priv. arch.
        InstructionInformation {
            mnemonic: "lbu",
            op_code: 0x24,
            funct_code: None,
            implementation: wrap_imp(implementation::lbu),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // LBUE (load byte unsigned EVA) doesn't apply.
        InstructionInformation {
            mnemonic: "ldc1",
            op_code: 0x35,
            funct_code: None,
            implementation: wrap_imp(implementation::ldc1),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Ft, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Ft, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier],
                &[ArgumentType::Ft, ArgumentType::Immediate],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ldxc1",
            op_code: 0x13,
            funct_code: Some(0x01),
            implementation: wrap_imp(implementation::ldxc1),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Fd, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "lh",
            op_code: 0x21,
            funct_code: None,
            implementation: wrap_imp(implementation::lh),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lhe (load half EVA) ignored
        InstructionInformation {
            mnemonic: "lhu",
            op_code: 0x25,
            funct_code: None,
            implementation: wrap_imp(implementation::lhu),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lhue (load half unsigned EVA) ignored
        InstructionInformation {
            mnemonic: "ll",
            op_code: 0x30,
            funct_code: None,
            implementation: wrap_imp(implementation::ll),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lle (load linked EVA) ignored
        InstructionInformation {
            mnemonic: "lui",
            op_code: 0x0F,
            funct_code: None,
            implementation: wrap_imp(implementation::lui),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Hi16),
        },
        InstructionInformation {
            mnemonic: "luxc1",
            op_code: 0x13,
            funct_code: Some(0x05),
            implementation: wrap_imp(implementation::luxc1),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Fd, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "lw",
            op_code: 0x23,
            funct_code: None,
            implementation: wrap_imp(implementation::lw),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "lwc1",
            op_code: 0x31,
            funct_code: None,
            implementation: wrap_imp(implementation::lwc1),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Ft, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Ft, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier],
                &[ArgumentType::Ft, ArgumentType::Immediate],
            ]),
            relocation_type: Some(RelocationEntryType::Lo16),
        },
        // lwe (load word EVA) ignored
        InstructionInformation {
            mnemonic: "lwl",
            op_code: 0x22,
            funct_code: None,
            implementation: wrap_imp(implementation::lwl),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lwle (load word left EVA) ignored
        InstructionInformation {
            mnemonic: "lwr",
            op_code: 0x26,
            funct_code: None,
            implementation: wrap_imp(implementation::lwr),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lwre (load word right EVA) ignored
        InstructionInformation {
            mnemonic: "lwxc1",
            op_code: 0x13,
            funct_code: Some(0),
            implementation: wrap_imp(implementation::lwxc1),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Fd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "madd",
            op_code: 0x1c,
            funct_code: Some(0x00),
            implementation: wrap_imp(implementation::madd),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "maddu",
            op_code: 0x1c,
            funct_code: Some(0x01),
            implementation: wrap_imp(implementation::maddu),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "mfc0",
            op_code: 0x10,
            funct_code: Some(0x00),
            implementation: wrap_imp(implementation::mfc0),
            instruction_type: InstructionType::CopMovRType,
            args: &[ArgumentType::Rt, ArgumentType::Rd],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rd, ArgumentType::Immediate],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "nor",
            op_code: 0x00,
            funct_code: Some(0x27),
            implementation: wrap_imp(implementation::nor),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "nop",
            op_code: 0x00,
            funct_code: Some(0x00),
            implementation: wrap_imp(implementation::sll),
            instruction_type: InstructionType::RType,
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "or",
            op_code: 0x00,
            funct_code: Some(0x25),
            implementation: wrap_imp(implementation::or),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ori",
            op_code: 0x0D,
            funct_code: None,
            implementation: wrap_imp(implementation::ori),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Lo16),
        },
        InstructionInformation {
            mnemonic: "sb",
            op_code: 0x28,
            funct_code: None,
            implementation: wrap_imp(implementation::sb),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sdc1",
            op_code: 0x3D,
            funct_code: None,
            implementation: wrap_imp(implementation::sdc1),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Ft, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Ft, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier],
                &[ArgumentType::Ft, ArgumentType::Immediate],
            ]),
            relocation_type: Some(RelocationEntryType::Lo16),
        },
        InstructionInformation {
            mnemonic: "sll",
            op_code: 0x00,
            funct_code: Some(0x00),
            implementation: wrap_imp(implementation::sll),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "slt",
            op_code: 0x00,
            funct_code: Some(0x2A),
            implementation: wrap_imp(implementation::slt),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "slti",
            op_code: 0x0A,
            funct_code: None,
            implementation: wrap_imp(implementation::slti),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sltiu",
            op_code: 0x0B,
            funct_code: None,
            implementation: wrap_imp(implementation::sltiu),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sltu",
            op_code: 0x00,
            funct_code: Some(0x2B),
            implementation: wrap_imp(implementation::sltu),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "srl",
            op_code: 0x00,
            funct_code: Some(0x02),
            implementation: wrap_imp(implementation::srl),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sub",
            op_code: 0x00,
            funct_code: Some(0x22),
            implementation: wrap_imp(implementation::sub),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "subu",
            op_code: 0x00,
            funct_code: Some(0x23),
            implementation: wrap_imp(implementation::subu),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sw",
            op_code: 0x2B,
            funct_code: None,
            implementation: wrap_imp(implementation::sw),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "syscall",
            op_code: 0x00,
            funct_code: Some(0x0C),
            implementation: wrap_imp(implementation::syscall),
            instruction_type: InstructionType::RType,
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "xor",
            op_code: 0x00,
            funct_code: Some(0x26),
            implementation: wrap_imp(implementation::xor),
            instruction_type: InstructionType::RType,
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "xori",
            op_code: 0x0E,
            funct_code: None,
            implementation: wrap_imp(implementation::xori),
            instruction_type: InstructionType::IType,
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
    ]
});

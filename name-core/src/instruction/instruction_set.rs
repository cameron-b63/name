use crate::{
    elf_def::RelocationEntryType,
    instruction::{
        formats::{
            bit_field_type::BitFieldArgs, cache_type::CacheArgs, cop_mov_r_type::CopMovRArgs,
            i_type::IArgs, j_type::JArgs, r_type::RArgs, regimm_i_type::RegImmIArgs,
        },
        implementation,
        information::{wrap_imp, ArgumentType, InstructionInformation, InstructionType},
    },
};

use std::sync::LazyLock;

/// This is the entire implemented instruction set (regular CPU instructions) for NAME.
/// The assembler searches through this table using the mnemonic field.
/// The emulator performs a lookup based on opcode and funct_code, and then uses the associated implementation.
/// The implementation below is based on the following [specification](https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf).

// The definition for this struct is very descriptive - I encourage you to go read it.
pub static INSTRUCTION_SET: LazyLock<Vec<InstructionInformation>> = LazyLock::new(|| {
    vec![
        InstructionInformation {
            mnemonic: "add",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x20,
            }),
            implementation: wrap_imp(implementation::add),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "addi",
            basis: InstructionType::IType(IArgs {
                opcode: 0x08,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::addi),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "addiu",
            basis: InstructionType::IType(IArgs {
                opcode: 0x09,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::addiu),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "addu",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x21,
            }),
            implementation: wrap_imp(implementation::addu),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "and",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x24,
            }),
            implementation: wrap_imp(implementation::and),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "andi",
            basis: InstructionType::IType(IArgs {
                opcode: 0x0c,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::andi),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "beq",
            basis: InstructionType::IType(IArgs {
                opcode: 0x04,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::beq),
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "beql",
            basis: InstructionType::IType(IArgs {
                opcode: 0x14,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::beql),
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgez",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x01,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bgez),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgezal",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x11,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bgezal),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgezall",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x13,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bgezall),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgezl",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x03,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bgezl),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgtz",
            basis: InstructionType::IType(IArgs {
                opcode: 0x07,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bgtz),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bgtzl",
            basis: InstructionType::IType(IArgs {
                opcode: 0x17,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bgtzl),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "blez",
            basis: InstructionType::IType(IArgs {
                opcode: 0x06,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::blez),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "blezl",
            basis: InstructionType::IType(IArgs {
                opcode: 0x16,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::blezl),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltz",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x00,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bltz),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltzal",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x10,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bltzal),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltzall",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x12,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bltzall),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bltzl",
            basis: InstructionType::RegImmIType(RegImmIArgs {
                opcode: 0x01,
                rs: 0,
                regimm_funct_code: 0x02,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bltzl),
            args: &[ArgumentType::Rs, ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bne",
            basis: InstructionType::IType(IArgs {
                opcode: 0x05,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bne),
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "bnel",
            basis: InstructionType::IType(IArgs {
                opcode: 0x15,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::bnel),
            args: &[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rs, ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Pc16),
        },
        InstructionInformation {
            mnemonic: "break",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x0d,
            }),
            implementation: wrap_imp(implementation::break_instr),
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "cache",
            basis: InstructionType::CacheType(CacheArgs {
                opcode: 0x2f,
                base: 0,
                op: 0,
                offset: 0,
            }),
            implementation: wrap_imp(implementation::cache),
            args: &[
                ArgumentType::Immediate,
                ArgumentType::Immediate,
                ArgumentType::Rs,
            ],
            alt_args: None,
            relocation_type: None,
        },
        // I'm going to purposefully ignore CACHEE since we don't have an acutal priviliged resource setup.
        InstructionInformation {
            mnemonic: "clo",
            basis: InstructionType::RType(RArgs {
                opcode: 0x1c,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x21,
            }),
            implementation: wrap_imp(implementation::clo),
            args: &[ArgumentType::Rd, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "clz",
            basis: InstructionType::RType(RArgs {
                opcode: 0x1c,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x20,
            }),
            implementation: wrap_imp(implementation::clz),
            args: &[ArgumentType::Rd, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        // I'm ignoring DERET as it doesn't apply to use yet.
        // I'm ignoring the DI (disable interrupts) instruction
        // since I don't even know where to really start.
        // I know for sure that it doesn't really apply to us.
        InstructionInformation {
            mnemonic: "div",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x1a,
            }),
            implementation: wrap_imp(implementation::div),
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "divu",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x1b,
            }),
            implementation: wrap_imp(implementation::divu),
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        // Similarly ignoring EI (enable interrupts).
        // See DI.
        // Ignoring ERET and ERETNC
        InstructionInformation {
            mnemonic: "ext",
            basis: InstructionType::BitFieldType(BitFieldArgs {
                opcode: 0x1f,
                rs: 0,
                rt: 0,
                msbd: 0,
                lsb: 0,
                funct: 0x00,
            }),
            implementation: wrap_imp(implementation::ext),
            args: &[
                ArgumentType::Rt,
                ArgumentType::Rs,
                ArgumentType::Immediate,
                ArgumentType::Immediate,
            ],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ins",
            basis: InstructionType::BitFieldType(BitFieldArgs {
                opcode: 0x1f,
                rs: 0,
                rt: 0,
                msbd: 0,
                lsb: 0,
                funct: 0x04,
            }),
            implementation: wrap_imp(implementation::ins),
            args: &[
                ArgumentType::Rt,
                ArgumentType::Rs,
                ArgumentType::Immediate,
                ArgumentType::Immediate,
            ],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "j",
            basis: InstructionType::JType(JArgs {
                opcode: 0x02,
                address: 0,
            }),
            implementation: wrap_imp(implementation::j),
            args: &[ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::R26),
        },
        InstructionInformation {
            mnemonic: "jal",
            basis: InstructionType::JType(JArgs {
                opcode: 0x03,
                address: 0,
            }),
            implementation: wrap_imp(implementation::jal),
            args: &[ArgumentType::Identifier],
            alt_args: None,
            relocation_type: Some(RelocationEntryType::R26),
        },
        InstructionInformation {
            mnemonic: "jalr",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x09,
            }),
            implementation: wrap_imp(implementation::jalr),
            args: &[ArgumentType::Rd, ArgumentType::Rs],
            alt_args: Some(&[&[ArgumentType::Rs]]),
            relocation_type: None,
        },
        // I'm going to purposefully ignore *.HB because
        // that's some hardware business I won't get to for a long time.
        // JALX also doesn't apply since we're not including micro MIPS.
        InstructionInformation {
            mnemonic: "jr",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x08,
            }),
            implementation: wrap_imp(implementation::jr),
            args: &[ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        // JR.HB is ignored, as stated above.
        InstructionInformation {
            mnemonic: "lb",
            basis: InstructionType::IType(IArgs {
                opcode: 0x20,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lb),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // LBE (load byte EVA) doesn't apply to us since we don't have priv. arch.
        InstructionInformation {
            mnemonic: "lbu",
            basis: InstructionType::IType(IArgs {
                opcode: 0x24,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lbu),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // LBUE (load byte unsigned EVA) doesn't apply.
        InstructionInformation {
            mnemonic: "ldc1",
            basis: InstructionType::IType(IArgs {
                opcode: 0x35,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::ldc1),
            args: &[ArgumentType::Ft, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Ft, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier],
                &[ArgumentType::Ft, ArgumentType::Immediate],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ldxc1",
            basis: InstructionType::RType(RArgs {
                opcode: 0x13,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x01,
            }),
            implementation: wrap_imp(implementation::ldxc1),
            args: &[ArgumentType::Fd, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "lh",
            basis: InstructionType::IType(IArgs {
                opcode: 0x21,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lh),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lhe (load half EVA) ignored
        InstructionInformation {
            mnemonic: "lhu",
            basis: InstructionType::IType(IArgs {
                opcode: 0x25,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lhu),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lhue (load half unsigned EVA) ignored
        InstructionInformation {
            mnemonic: "ll",
            basis: InstructionType::IType(IArgs {
                opcode: 0x30,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::ll),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lle (load linked EVA) ignored
        InstructionInformation {
            mnemonic: "lui",
            basis: InstructionType::IType(IArgs {
                opcode: 0x0f,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lui),
            args: &[ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rt, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Hi16),
        },
        InstructionInformation {
            mnemonic: "luxc1",
            basis: InstructionType::RType(RArgs {
                opcode: 0x13,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x05,
            }),
            implementation: wrap_imp(implementation::luxc1),
            args: &[ArgumentType::Fd, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "lw",
            basis: InstructionType::IType(IArgs {
                opcode: 0x23,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lw),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "lwc1",
            basis: InstructionType::IType(IArgs {
                opcode: 0x31,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lwc1),
            args: &[ArgumentType::Ft, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Ft, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier],
                &[ArgumentType::Ft, ArgumentType::Immediate],
            ]),
            relocation_type: Some(RelocationEntryType::Lo16),
        },
        // lwe (load word EVA) ignored
        InstructionInformation {
            mnemonic: "lwl",
            basis: InstructionType::IType(IArgs {
                opcode: 0x22,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lwl),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lwle (load word left EVA) ignored
        InstructionInformation {
            mnemonic: "lwr",
            basis: InstructionType::IType(IArgs {
                opcode: 0x26,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::lwr),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
            ]),
            relocation_type: None,
        },
        // lwre (load word right EVA) ignored
        InstructionInformation {
            mnemonic: "lwxc1",
            basis: InstructionType::RType(RArgs {
                opcode: 0x13,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x00,
            }),
            implementation: wrap_imp(implementation::lwxc1),
            args: &[ArgumentType::Fd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "madd",
            basis: InstructionType::RType(RArgs {
                opcode: 0x1c,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x00,
            }),
            implementation: wrap_imp(implementation::madd),
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "maddu",
            basis: InstructionType::RType(RArgs {
                opcode: 0x1c,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x01,
            }),
            implementation: wrap_imp(implementation::maddu),
            args: &[ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "mfc0",
            basis: InstructionType::CopMovRType(CopMovRArgs {
                opcode: 0x10,
                funct_code: 0x00,
                rt: 0,
                rd: 0,
                sel: 0,
            }),
            implementation: wrap_imp(implementation::mfc0),
            args: &[ArgumentType::Rt, ArgumentType::Rd],
            alt_args: Some(&[&[ArgumentType::Rt, ArgumentType::Rd, ArgumentType::Immediate]]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "nor",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x27,
            }),

            implementation: wrap_imp(implementation::nor),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "or",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x25,
            }),
            implementation: wrap_imp(implementation::or),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "ori",
            basis: InstructionType::IType(IArgs {
                opcode: 0x0d,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::ori),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: Some(&[&[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Identifier]]),
            relocation_type: Some(RelocationEntryType::Lo16),
        },
        InstructionInformation {
            mnemonic: "sb",
            basis: InstructionType::IType(IArgs {
                opcode: 0x28,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::sb),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sdc1",
            basis: InstructionType::IType(IArgs {
                opcode: 0x3d,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::sdc1),
            args: &[ArgumentType::Ft, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Ft, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Ft, ArgumentType::Identifier],
                &[ArgumentType::Ft, ArgumentType::Immediate],
            ]),
            relocation_type: Some(RelocationEntryType::Lo16),
        },
        InstructionInformation {
            mnemonic: "sll",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x00,
            }),
            implementation: wrap_imp(implementation::sll),
            args: &[ArgumentType::Rd, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "slt",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x2a,
            }),
            implementation: wrap_imp(implementation::slt),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "slti",
            basis: InstructionType::IType(IArgs {
                opcode: 0x0a,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::slti),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sltiu",
            basis: InstructionType::IType(IArgs {
                opcode: 0x0b,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::sltiu),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sltu",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x2b,
            }),
            implementation: wrap_imp(implementation::sltu),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "srl",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x02,
            }),
            implementation: wrap_imp(implementation::srl),
            args: &[ArgumentType::Rd, ArgumentType::Rt, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sub",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x22,
            }),
            implementation: wrap_imp(implementation::sub),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "subu",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x23,
            }),
            implementation: wrap_imp(implementation::subu),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "sw",
            basis: InstructionType::IType(IArgs {
                opcode: 0x2b,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::sw),
            args: &[ArgumentType::Rt, ArgumentType::Immediate, ArgumentType::Rs],
            alt_args: Some(&[
                &[ArgumentType::Rt, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier, ArgumentType::Rs],
                &[ArgumentType::Rt, ArgumentType::Identifier],
            ]),
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "syscall",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x0c,
            }),
            implementation: wrap_imp(implementation::syscall),
            args: &[],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "xor",
            basis: InstructionType::RType(RArgs {
                opcode: 0x00,
                rs: 0,
                rt: 0,
                rd: 0,
                shamt: 0,
                funct: 0x26,
            }),
            implementation: wrap_imp(implementation::xor),
            args: &[ArgumentType::Rd, ArgumentType::Rs, ArgumentType::Rt],
            alt_args: None,
            relocation_type: None,
        },
        InstructionInformation {
            mnemonic: "xori",
            basis: InstructionType::IType(IArgs {
                opcode: 0x0e,
                rs: 0,
                rt: 0,
                imm: 0,
            }),
            implementation: wrap_imp(implementation::xori),
            args: &[ArgumentType::Rt, ArgumentType::Rs, ArgumentType::Immediate],
            alt_args: None,
            relocation_type: None,
        },
    ]
});
